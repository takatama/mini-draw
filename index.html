<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini Draw</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        min-height: 100vh;
        width: 100%;
        box-sizing: border-box;
      }

      .flex-center {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        width: 100%;
        max-width: 340px;
      }

      .container-width {
        max-width: 340px;
        width: 100%;
      }

      .canvas-container {
        position: relative;
        width: 340px;
        height: 340px;
      }

      .spinner {
        width: 100px;
        height: 100px;
        border: 20px solid lightgray;
        border-top: 20px solid gray;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        display: none;
        z-index: 10;
      }

      canvas {
        border: 1px solid #000;
        touch-action: none;
        position: absolute;
        top: 0;
        left: 0;
      }

      .toolbar {
        margin-top: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .tool-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .eraser-indicator {
        border: 1px dashed black;
        border-radius: 50%;
        position: absolute;
        pointer-events: none;
        display: none;
        width: 20px;
        height: 20px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }

      label {
        margin-bottom: 5px;
      }

      img {
        max-width: 340px;
      }

      svg {
        width: 24px;
        height: 24px;
        vertical-align: middle;
      }

      #undo {
        margin-left: 20px;
      }
    </style>
  </head>

  <body>
    <div class="canvas-container flex-center">
      <canvas id="bgCanvas" width="340" height="340"></canvas>
      <canvas id="fgCanvas" width="340" height="340"></canvas>
      <div id="spinner" class="spinner"></div>
    </div>
    <div class="toolbar container-width">
      <div class="tool-group">
        <input
          type="radio"
          id="pencilMode"
          name="mode"
          value="pencil"
          checked
        />
        <label for="pencilMode">
          <!-- Pencil https://icons.getbootstrap.jp/ -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            fill="currentColor"
            class="bi bi-pencil"
            viewBox="0 0 16 16"
          >
            <path
              d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"
            />
          </svg>
        </label>

        <input type="radio" id="bucketMode" name="mode" value="bucket" />
        <label for="bucketMode">
          <!-- Bucket https://icons.getbootstrap.jp/ -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            fill="currentColor"
            class="bi bi-paint-bucket"
            viewBox="0 0 16 16"
            transform="scale(-1, 1)"
          >
            <path
              d="M6.192 2.78c-.458-.677-.927-1.248-1.35-1.643a2.972 2.972 0 0 0-.71-.515c-.217-.104-.56-.205-.882-.02-.367.213-.427.63-.43.896-.003.304.064.664.173 1.044.196.687.556 1.528 1.035 2.402L.752 8.22c-.277.277-.269.656-.218.918.055.283.187.593.36.903.348.627.92 1.361 1.626 2.068.707.707 1.441 1.278 2.068 1.626.31.173.62.305.903.36.262.05.64.059.918-.218l5.615-5.615c.118.257.092.512.05.939-.03.292-.068.665-.073 1.176v.123h.003a1 1 0 0 0 1.993 0H14v-.057a1.01 1.01 0 0 0-.004-.117c-.055-1.25-.7-2.738-1.86-3.494a4.322 4.322 0 0 0-.211-.434c-.349-.626-.92-1.36-1.627-2.067-.707-.707-1.441-1.279-2.068-1.627-.31-.172-.62-.304-.903-.36-.262-.05-.64-.058-.918.219l-.217.216zM4.16 1.867c.381.356.844.922 1.311 1.632l-.704.705c-.382-.727-.66-1.402-.813-1.938a3.283 3.283 0 0 1-.131-.673c.091.061.204.15.337.274zm.394 3.965c.54.852 1.107 1.567 1.607 2.033a.5.5 0 1 0 .682-.732c-.453-.422-1.017-1.136-1.564-2.027l1.088-1.088c.054.12.115.243.183.365.349.627.92 1.361 1.627 2.068.706.707 1.44 1.278 2.068 1.626.122.068.244.13.365.183l-4.861 4.862a.571.571 0 0 1-.068-.01c-.137-.027-.342-.104-.608-.252-.524-.292-1.186-.8-1.846-1.46-.66-.66-1.168-1.32-1.46-1.846-.147-.265-.225-.47-.251-.607a.573.573 0 0 1-.01-.068l3.048-3.047zm2.87-1.935a2.44 2.44 0 0 1-.241-.561c.135.033.324.11.562.241.524.292 1.186.8 1.846 1.46.45.45.83.901 1.118 1.31a3.497 3.497 0 0 0-1.066.091 11.27 11.27 0 0 1-.76-.694c-.66-.66-1.167-1.322-1.458-1.847z"
            />
          </svg>
        </label>

        <input type="radio" id="eraserMode" name="mode" value="eraser" />
        <label for="eraserMode">
          <!-- Eraser https://icons.getbootstrap.jp/ -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            fill="currentColor"
            class="bi bi-eraser"
            viewBox="0 0 16 16"
          >
            <path
              d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm2.121.707a1 1 0 0 0-1.414 0L4.16 7.547l5.293 5.293 4.633-4.633a1 1 0 0 0 0-1.414l-3.879-3.879zM8.746 13.547 3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z"
            />
          </svg>
        </label>

        <input type="radio" id="bgColorMode" name="mode" value="background" />
        <label for="bgColorMode">
          <svg
            id="bgIcon"
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            fill="#FFFFEF"
            class="bi bi-square-fill"
            viewBox="0 0 16 16"
          >
            <rect
              width="16"
              height="16"
              rx="2"
              ry="2"
              stroke="#000000"
              stroke-width="1"
            />
          </svg>
        </label>
      </div>
      <button id="undo">Undo</button>
    </div>
    <div class="toolbar container-width">
      <div class="tool-group">
        <label id="mode-label">Pencil</label>
        <input
          type="color"
          id="fg-color-picker"
          class="fg-color-picker"
          value="#000000"
        />
        <input
          type="range"
          id="thickness-slider"
          class="thickness-slider"
          min="1"
          max="100"
          value="1"
        />
        <input
          type="range"
          id="eraser-size-slider"
          class="eraser-size-slider"
          min="1"
          max="50"
          value="20"
        />
        <input
          type="color"
          id="bg-color-picker"
          class="bg-color-picker"
          value="#FFFFEF"
        />
      </div>
    </div>
    <div class="toolbar">
      <button id="clearCanvas">Clear</button>
    </div>
    <div id="eraserIndicator" class="eraser-indicator"></div>

    <script>
      const CANVAS_WIDTH = 340;
      const CANVAS_HEIGHT = 340;

      const bgCanvas = document.getElementById("bgCanvas");
      const bgCtx = bgCanvas.getContext("2d");
      const fgCanvas = document.getElementById("fgCanvas");
      fgCanvas.style.willReadFrequently = true;
      const fgCtx = fgCanvas.getContext("2d");
      const eraserIndicator = document.getElementById("eraserIndicator");
      const undoStack = [];

      let isDrawing = false;
      let currentMode = "pencil";
      let currentColor = "#000000";
      let currentThickness = 1;
      let eraserSize = 20;

      function initialize() {
        setupEventListeners();
        clearCanvas();
        showTools(currentMode);
      }

      function showTools(mode) {
        const tools = {
          pencil: ["fg-color-picker", "thickness-slider"],
          bucket: ["fg-color-picker"],
          eraser: ["eraser-size-slider"],
          background: ["bg-color-picker"],
        };
        Object.values(tools).forEach((ids) =>
          ids.forEach(
            (id) => (document.getElementById(id).style.display = "none")
          )
        );
        tools[mode].forEach(
          (id) => (document.getElementById(id).style.display = "block")
        );
      }

      function setupEventListeners() {
        fgCanvas.addEventListener("touchstart", handleStart);
        fgCanvas.addEventListener("touchmove", handleMove);
        fgCanvas.addEventListener("touchend", handleEnd);

        fgCanvas.addEventListener("mousedown", handleStart);
        fgCanvas.addEventListener("mousemove", handleMove);
        fgCanvas.addEventListener("mouseup", handleEnd);
        fgCanvas.addEventListener("mouseout", handleEnd);

        document.getElementsByName("mode").forEach((radio) => {
          radio.addEventListener("change", (event) => {
            currentMode = event.target.value;
            const capitalizedMode =
              currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
            document.body.className = `tool-${currentMode}`;
            eraserIndicator.style.display = "none";
            document.getElementById("mode-label").textContent = capitalizedMode;
            showTools(currentMode);
          });
        });

        // 初期状態の設定
        const initialMode = document.querySelector(
          'input[name="mode"]:checked'
        ).value;
        document.getElementById("mode-label").textContent =
          initialMode.charAt(0).toUpperCase() + initialMode.slice(1);

        document
          .getElementById("fg-color-picker")
          .addEventListener("input", (event) => {
            currentColor = event.target.value;
          });

        document
          .getElementById("thickness-slider")
          .addEventListener("input", (event) => {
            currentThickness = event.target.value;
          });

        document
          .getElementById("eraser-size-slider")
          .addEventListener("input", (event) => {
            eraserSize = event.target.value;
            eraserIndicator.style.width = eraserSize + "px";
            eraserIndicator.style.height = eraserSize + "px";
          });

        document
          .getElementById("bg-color-picker")
          .addEventListener("input", (event) => {
            saveState();
            bgCtx.fillStyle = event.target.value;
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
            document
              .getElementById("bgIcon")
              .setAttribute("fill", event.target.value);
          });

        document
          .getElementById("clearCanvas")
          .addEventListener("click", clearCanvas);
        document.getElementById("undo").addEventListener("click", undo);

        fgCanvas.addEventListener("click", (event) => {
          if (currentMode === "bucket") {
            const { x, y } = getPosition(event);
            const fillColor = hexToRgbA(
              document.getElementById("fg-color-picker").value
            );
            saveState();
            bucketFill(x, y, fillColor);
          }
        });
      }

      function clearCanvas() {
        fgCtx.clearRect(0, 0, fgCanvas.width, fgCanvas.height);
        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        bgCtx.fillStyle = document.getElementById("bg-color-picker").value;
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        undoStack.length = 0;
      }

      function saveState() {
        const state = {
          background: bgCanvas.toDataURL(),
          drawing: fgCanvas.toDataURL(),
        };
        undoStack.push(state);
      }

      function undo() {
        if (undoStack.length > 0) {
          const lastState = undoStack.pop();

          const lastBackground = new Image();
          lastBackground.src = lastState.background;
          lastBackground.onload = () => {
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            bgCtx.drawImage(lastBackground, 0, 0);
          };

          const lastDrawing = new Image();
          lastDrawing.src = lastState.drawing;
          lastDrawing.onload = () => {
            fgCtx.clearRect(0, 0, fgCanvas.width, fgCanvas.height);
            fgCtx.drawImage(lastDrawing, 0, 0);
          };
        }
      }

      function handleStart(event) {
        const { x, y } = getPosition(event);

        if (currentMode === "pencil") {
          eraserIndicator.style.display = "none";
          startDrawing(x, y);
          isDrawing = true;
        } else if (currentMode === "eraser") {
          setIndicatorPosition(eraserIndicator, event);
        }
      }

      function handleMove(event) {
        if (!isDrawing && currentMode !== "eraser") return;
        const { x, y } = getPosition(event);

        if (isDrawing && currentMode === "pencil") {
          drawLine(x, y);
        } else if (currentMode === "eraser") {
          const withinCanvasBounds =
            x - eraserSize / 2 > 0 &&
            x + eraserSize / 2 < CANVAS_WIDTH &&
            y - eraserSize / 2 > 0 &&
            y + eraserSize / 2 < CANVAS_HEIGHT;
          eraserIndicator.style.display = withinCanvasBounds ? "block" : "none";
          setIndicatorPosition(eraserIndicator, event);
          if (event.buttons === 1 || event.touches) {
            erase(x, y);
          }
        }
      }

      function handleEnd() {
        isDrawing = false;
      }

      function getPosition(event) {
        const rect = fgCanvas.getBoundingClientRect();
        const x = (event.clientX || event.touches[0].clientX) - rect.left;
        const y = (event.clientY || event.touches[0].clientY) - rect.top;
        return { x, y };
      }

      function setIndicatorPosition(indicator, event) {
        const x =
          (event.clientX || event.touches[0].clientX) -
          eraserSize / 2 +
          window.scrollX;
        const y =
          (event.clientY || event.touches[0].clientY) -
          eraserSize / 2 +
          window.scrollY;
        indicator.style.left = x + "px";
        indicator.style.top = y + "px";
      }

      function startDrawing(x, y) {
        fgCtx.lineCap = "round";
        fgCtx.lineJoin = "round";
        fgCtx.beginPath();
        fgCtx.moveTo(x, y);
        saveState();
      }

      function drawLine(x, y) {
        fgCtx.strokeStyle = currentColor;
        fgCtx.lineWidth = currentThickness;
        fgCtx.lineTo(x, y);
        fgCtx.stroke();
      }

      function erase(x, y) {
        fgCtx.save();
        fgCtx.globalCompositeOperation = "destination-out";
        fgCtx.beginPath();
        fgCtx.arc(x, y, eraserSize / 2, 0, Math.PI * 2, false);
        fgCtx.fill();
        fgCtx.restore();
      }

      function bucketFill(x, initialY, fillColor) {
        x = Math.floor(x); // 座標を整数に丸める
        initialY = Math.floor(initialY); // 座標を整数に丸める
        console.log(
          `Starting fill at (${x}, ${initialY}) with color:`,
          fillColor
        );

        let pixelStack = [[x, initialY]];
        const canvasWidth = fgCanvas.width;
        const canvasHeight = fgCanvas.height;

        const context = fgCtx;
        const imageData = context.getImageData(0, 0, canvasWidth, canvasHeight);
        const data = imageData.data;

        let startPos = (initialY * canvasWidth + x) * 4;
        const startColor = [
          data[startPos],
          data[startPos + 1],
          data[startPos + 2],
          data[startPos + 3],
        ];
        console.log("Start color:", startColor);

        if (!colorMatch(startColor, fillColor)) {
          while (pixelStack.length) {
            const newPos = pixelStack.pop();
            let [x, y] = newPos;

            console.log(`Popped position: (${x}, ${y})`);

            let currentPos = (y * canvasWidth + x) * 4;

            while (
              y >= 0 &&
              colorMatch(getColorAt(data, currentPos), startColor)
            ) {
              y--;
              currentPos -= canvasWidth * 4;
            }

            currentPos += canvasWidth * 4;
            let reachLeft = false;
            let reachRight = false;

            while (
              y < canvasHeight &&
              colorMatch(getColorAt(data, currentPos), startColor)
            ) {
              setColorAt(data, currentPos, fillColor);
              console.log(`Filling position: (${x}, ${y})`);

              if (x > 0) {
                if (colorMatch(getColorAt(data, currentPos - 4), startColor)) {
                  if (!reachLeft) {
                    pixelStack.push([x - 1, y]);
                    reachLeft = true;
                    console.log(`Pushed left: (${x - 1}, ${y})`);
                  }
                } else if (reachLeft) {
                  reachLeft = false;
                }
              }

              if (x < canvasWidth - 1) {
                if (colorMatch(getColorAt(data, currentPos + 4), startColor)) {
                  if (!reachRight) {
                    pixelStack.push([x + 1, y]);
                    reachRight = true;
                    console.log(`Pushed right: (${x + 1}, ${y})`);
                  }
                } else if (reachRight) {
                  reachRight = false;
                }
              }

              y++;
              currentPos += canvasWidth * 4;
            }
          }

          context.putImageData(imageData, 0, 0);
          console.log("Fill complete.");
        } else {
          console.log(
            "Start color and fill color are the same. No fill needed."
          );
        }
      }

      function getColorAt(data, pos) {
        return [data[pos], data[pos + 1], data[pos + 2], data[pos + 3]];
      }

      function setColorAt(data, pos, color) {
        data[pos] = color[0];
        data[pos + 1] = color[1];
        data[pos + 2] = color[2];
        data[pos + 3] = color[3];
      }

      function colorMatch(a, b, tolerance = 32) {
        return (
          Math.abs(a[0] - b[0]) < tolerance &&
          Math.abs(a[1] - b[1]) < tolerance &&
          Math.abs(a[2] - b[2]) < tolerance &&
          Math.abs(a[3] - b[3]) < tolerance
        );
      }

      function hexToRgbA(hex) {
        let c;
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
          c = hex.substring(1).split("");
          if (c.length == 3) {
            c = [c[0], c[0], c[1], c[1], c[2], c[2]];
          }
          c = "0x" + c.join("");
          return [(c >> 16) & 255, (c >> 8) & 255, c & 255, 255];
        }
        throw new Error("Bad Hex");
      }

      window.onload = initialize;
    </script>
  </body>
</html>
